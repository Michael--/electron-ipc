/**
 * Creates the file header for generated IPC API files
 * @returns File header with auto-generation warning and lint/prettier ignores
 */
export const createFileHeader = () => `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

import { contextBridge, ipcRenderer } from "electron"

// ============================================================================
// Inline Trace Helpers (for Inspector)
// ============================================================================

type TraceContext = { traceId: string, spanId: string, parentSpanId?: string }
type TraceOptions = { trace?: TraceContext }
type TraceEnvelopePayload<T> = { __ipcTrace: TraceContext, __ipcData: T }

const TRACE_CONTEXT_KEY = '__ipcTrace'
const TRACE_DATA_KEY = '__ipcData'

function isTraceEnvelopePayload(value: any): value is TraceEnvelopePayload<any> {
  if (!value || typeof value !== 'object') return false
  const record = value as { [key: string]: any }
  if (!(TRACE_CONTEXT_KEY in record) || !(TRACE_DATA_KEY in record)) return false
  const trace = record[TRACE_CONTEXT_KEY]
  return (
    trace &&
    typeof trace === 'object' &&
    typeof trace.traceId === 'string' &&
    typeof trace.spanId === 'string' &&
    (trace.parentSpanId === undefined || typeof trace.parentSpanId === 'string')
  )
}

function wrapTracePayload<T>(payload: T, trace?: TraceContext): T | TraceEnvelopePayload<T> {
  if (!trace) return payload
  if (isTraceEnvelopePayload(payload)) return payload
  return { [TRACE_CONTEXT_KEY]: trace, [TRACE_DATA_KEY]: payload } as TraceEnvelopePayload<T>
}

function unwrapTracePayload<T>(
  input: T | TraceEnvelopePayload<T>
): { payload: T, trace?: TraceContext } {
  if (isTraceEnvelopePayload(input)) {
    return { payload: input.__ipcData, trace: input.__ipcTrace }
  }
  return { payload: input as T }
}

let tracingEnabled = true

/** Checks if tracing should be enabled for this channel */
function shouldTraceChannel(channel: string): boolean {
  if (!tracingEnabled) return false
  // Never trace Inspector IPC (prevent circular tracing)
  if (channel.startsWith('INSPECTOR:')) return false
  return true
}

/** Generates a unique trace ID */
function generateTraceId(): string {
  return \`\${Date.now().toString(36)}-\${Math.random().toString(36).slice(2, 8)}\`
}

/** Generates a unique span ID */
function generateSpanId(): string {
  return Math.random().toString(36).slice(2, 8)
}

/** Creates a trace context for correlation */
function createTraceContext(parent?: TraceContext): TraceContext {
  if (parent) {
    return { traceId: parent.traceId, spanId: generateSpanId(), parentSpanId: parent.spanId }
  }

  const traceId = generateTraceId()
  return { traceId, spanId: traceId }
}

/** Creates a trace envelope with timestamps */
function createTraceEnvelope(
  context: TraceContext,
  tsStart: number,
  tsEnd?: number
): { traceId: string, spanId: string, parentSpanId?: string, tsStart: number, tsEnd?: number } {
  if (tsEnd === undefined) return { ...context, tsStart }
  return { ...context, tsStart, tsEnd }
}

/** Calculates byte size of JSON-serializable data */
function calculateBytes(data: any): number {
  try {
    return new Blob([JSON.stringify(data)]).size
  } catch {
    return 0
  }
}

/** Gets current payload mode from main process */
let cachedPayloadMode: 'none' | 'redacted' | 'full' = 'redacted'
// Silently try to get initial mode from main process (Inspector may not be enabled)
ipcRenderer.invoke('INSPECTOR:GET_PAYLOAD_MODE')
  .then((mode) => {
    if (mode) cachedPayloadMode = mode
  })
  .catch(() => {
    // Inspector not enabled - silently ignore
  })

// Silently try to get initial tracing state from main process
ipcRenderer.invoke('INSPECTOR:GET_STATUS')
  .then((status) => {
    if (status && typeof status.traceEnabled === 'boolean') {
      tracingEnabled = status.traceEnabled
    }
  })
  .catch(() => {
    // Inspector not enabled - silently ignore
  })

/** Creates a payload preview based on current mode */
function createPayloadPreview(data: any): { mode: 'none' | 'redacted' | 'full', bytes?: number, summary?: string, data?: any } {
  const bytes = calculateBytes(data)

  // Mode: none - no payload data at all
  if (cachedPayloadMode === 'none') {
    return { mode: 'none', bytes }
  }

  // Mode: full - include complete data
  if (cachedPayloadMode === 'full') {
    return { mode: 'full', bytes, data }
  }

  // Mode: redacted (default) - preview only
  let summary = ''
  try {
    const json = JSON.stringify(data)
    // Preview: first 100 chars
    summary = json.length > 100 ? json.slice(0, 100) + '...' : json
  } catch {
    summary = '[Non-serializable data]'
  }

  return { mode: 'redacted', bytes, summary }
}

/** Updates cached payload mode from main process */
ipcRenderer.on('INSPECTOR:PAYLOAD_MODE_CHANGED', (_event: any, mode: 'none' | 'redacted' | 'full') => {
  cachedPayloadMode = mode
})

/** Updates cached tracing state from main process */
ipcRenderer.on('INSPECTOR:TRACE_ENABLED_CHANGED', (_event: any, enabled: boolean) => {
  tracingEnabled = Boolean(enabled)
})

/** Traces an invoke IPC call */
async function traceInvoke<TRequest, TResponse>(
  channel: string,
  request: TRequest,
  invoke: (channel: string, request: TRequest) => Promise<TResponse>,
  parentTrace?: TraceContext
): Promise<TResponse> {
  if (!shouldTraceChannel(channel)) {
    return invoke(channel, request)
  }

  const traceContext = createTraceContext(parentTrace)
  const tsStart = Date.now()
  const requestWithTrace = wrapTracePayload(request, traceContext)

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceContext.spanId,
      kind: 'invoke',
      channel,
      direction: 'renderer→main',
      status: 'ok',
      tsStart,
      trace: createTraceEnvelope(traceContext, tsStart),
      source: { webContentsId: -1 },
      request: createPayloadPreview(request)
    })
  } catch {}

  try {
    const response = await invoke(channel, requestWithTrace as any)
    const tsEnd = Date.now()

    try {
      ipcRenderer.send('INSPECTOR:TRACE', {
        id: traceContext.spanId,
        kind: 'invoke',
        channel,
        direction: 'renderer→main',
        status: 'ok',
        tsStart,
        tsEnd,
        durationMs: tsEnd - tsStart,
        trace: createTraceEnvelope(traceContext, tsStart, tsEnd),
        source: { webContentsId: -1 },
        request: createPayloadPreview(request),
        response: createPayloadPreview(response)
      })
    } catch {}

    return response
  } catch (error) {
    const tsEnd = Date.now()

    try {
      ipcRenderer.send('INSPECTOR:TRACE', {
        id: traceContext.spanId,
        kind: 'invoke',
        channel,
        direction: 'renderer→main',
        status: 'error',
        tsStart,
        tsEnd,
        durationMs: tsEnd - tsStart,
        trace: createTraceEnvelope(traceContext, tsStart, tsEnd),
        source: { webContentsId: -1 },
        request: createPayloadPreview(request),
        error: {
          name: error instanceof Error ? error.name : 'Error',
          message: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined
        }
      })
    } catch {}

    throw error
  }
}

/** Traces an event IPC call */
function traceEvent<TPayload>(
  channel: string,
  payload: TPayload,
  parentTrace?: TraceContext
): TraceContext | null {
  if (!shouldTraceChannel(channel)) return null

  const traceContext = createTraceContext(parentTrace)
  const tsStart = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceContext.spanId,
      kind: 'event',
      channel,
      direction: 'renderer→main',
      status: 'ok',
      tsStart,
      trace: createTraceEnvelope(traceContext, tsStart),
      source: { webContentsId: -1 },
      payload: createPayloadPreview(payload)
    })
  } catch {}

  return traceContext
}

/** Traces a broadcast IPC event */
function traceBroadcast<TPayload>(
  channel: string,
  payload: TPayload,
  parentTrace?: TraceContext
): void {
  if (!shouldTraceChannel(channel)) return

  const traceContext = createTraceContext(parentTrace)
  const tsStart = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceContext.spanId,
      kind: 'broadcast',
      channel,
      direction: 'main→renderer',
      status: 'ok',
      tsStart,
      trace: createTraceEnvelope(traceContext, tsStart),
      target: { webContentsId: -1 },
      payload: createPayloadPreview(payload)
    })
  } catch {}
}

/** Traces a stream invoke IPC call */
function traceStreamInvoke(
  channel: string,
  request: any,
  parentTrace?: TraceContext
): TraceContext | null {
  if (!shouldTraceChannel(channel)) return null

  const traceContext = createTraceContext(parentTrace)
  const tsStart = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceContext.spanId,
      kind: 'streamInvoke',
      channel,
      direction: 'renderer→main',
      status: 'streaming',
      tsStart,
      trace: createTraceEnvelope(traceContext, tsStart),
      source: { webContentsId: -1 },
      request: createPayloadPreview(request)
    })
  } catch {}

  return traceContext
}

/** Updates stream invoke trace with chunk data */
function traceStreamInvokeChunk(
  traceContext: TraceContext | null,
  channel: string,
  chunk: any
): void {
  if (!traceContext || !shouldTraceChannel(channel)) return

  const tsStart = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceContext.spanId,
      kind: 'streamInvoke',
      channel,
      direction: 'renderer→main',
      status: 'streaming',
      tsStart,
      trace: createTraceEnvelope(traceContext, tsStart),
      source: { webContentsId: -1 },
      stream: createPayloadPreview(chunk)
    })
  } catch {}
}

/** Completes stream invoke trace */
function traceStreamInvokeEnd(
  traceContext: TraceContext | null,
  channel: string,
  tsStart: number,
  status: 'ok' | 'cancelled' | 'error' = 'ok',
  error?: any
): void {
  if (!traceContext || !shouldTraceChannel(channel)) return

  const tsEnd = Date.now()

  try {
    const event: any = {
      id: traceContext.spanId,
      kind: 'streamInvoke',
      channel,
      direction: 'renderer→main',
      status,
      tsStart,
      tsEnd,
      durationMs: tsEnd - tsStart,
      trace: createTraceEnvelope(traceContext, tsStart, tsEnd),
      source: { webContentsId: -1 }
    }

    if (status === 'error' && error) {
      event.error = {
        name: error instanceof Error ? error.name : 'Error',
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      }
    }

    ipcRenderer.send('INSPECTOR:TRACE', event)
  } catch {}
}

/** Marks stream invoke as errored */
function traceStreamInvokeError(
  traceContext: TraceContext | null,
  channel: string,
  tsStart: number,
  error: any
): void {
  if (!traceContext || !shouldTraceChannel(channel)) return

  const tsEnd = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceContext.spanId,
      kind: 'streamInvoke',
      channel,
      direction: 'renderer→main',
      status: 'error',
      tsStart,
      tsEnd,
      durationMs: tsEnd - tsStart,
      trace: createTraceEnvelope(traceContext, tsStart, tsEnd),
      source: { webContentsId: -1 },
      error: {
        name: error instanceof Error ? error.name : 'Error',
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      }
    })
  } catch {}
}

/** Traces a stream upload start */
function traceStreamUploadStart(
  channel: string,
  request: any,
  parentTrace?: TraceContext
): TraceContext | null {
  if (!shouldTraceChannel(channel)) return null

  const traceContext = createTraceContext(parentTrace)
  const tsStart = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceContext.spanId,
      kind: 'streamUpload',
      channel,
      direction: 'renderer→main',
      status: 'streaming',
      tsStart,
      trace: createTraceEnvelope(traceContext, tsStart),
      source: { webContentsId: -1 },
      request: createPayloadPreview(request)
    })
  } catch {}

  return traceContext
}

/** Traces a stream upload data chunk */
function traceStreamUploadData(
  traceContext: TraceContext | null,
  channel: string,
  chunk: any
): void {
  if (!traceContext || !shouldTraceChannel(channel)) return

  const tsStart = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceContext.spanId,
      kind: 'streamUpload',
      channel,
      direction: 'renderer→main',
      status: 'streaming',
      tsStart,
      trace: createTraceEnvelope(traceContext, tsStart),
      source: { webContentsId: -1 },
      data: createPayloadPreview(chunk)
    })
  } catch {}
}

/** Traces stream upload completion */
function traceStreamUploadEnd(
  traceContext: TraceContext | null,
  channel: string,
  status: 'ok' | 'cancelled' | 'error' = 'ok',
  error?: any,
  tsStart?: number
): void {
  if (!traceContext || !shouldTraceChannel(channel)) return

  const tsEnd = Date.now()
  const resolvedStart = tsStart ?? tsEnd

  try {
    const event: any = {
      id: traceContext.spanId,
      kind: 'streamUpload',
      channel,
      direction: 'renderer→main',
      status,
      tsStart: resolvedStart,
      tsEnd,
      durationMs: tsEnd - resolvedStart,
      trace: createTraceEnvelope(traceContext, resolvedStart, tsEnd),
      source: { webContentsId: -1 }
    }

    if (status === 'error' && error) {
      event.error = {
        name: error instanceof Error ? error.name : 'Error',
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      }
    }

    ipcRenderer.send('INSPECTOR:TRACE', event)
  } catch {}
}

/** Traces a stream download */
function traceStreamDownload(
  channel: string,
  chunk: any,
  parentTrace?: TraceContext
): void {
  if (!shouldTraceChannel(channel)) return

  const traceContext = parentTrace ?? createTraceContext()
  const tsStart = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceContext.spanId,
      kind: 'streamDownload',
      channel,
      direction: 'main→renderer',
      status: 'streaming',
      tsStart,
      trace: createTraceEnvelope(traceContext, tsStart),
      target: { webContentsId: -1 },
      data: createPayloadPreview(chunk)
    })
  } catch {}
}

/** Completes stream download trace */
function traceStreamDownloadEnd(
  traceContext: TraceContext | null,
  channel: string,
  tsStart: number,
  status: 'ok' | 'cancelled' | 'error' = 'ok',
  error?: any
): void {
  if (!traceContext || !shouldTraceChannel(channel)) return

  const tsEnd = Date.now()

  try {
    const event: any = {
      id: traceContext.spanId,
      kind: 'streamDownload',
      channel,
      direction: 'main→renderer',
      status,
      tsStart,
      tsEnd,
      durationMs: tsEnd - tsStart,
      trace: createTraceEnvelope(traceContext, tsStart, tsEnd),
      target: { webContentsId: -1 }
    }

    if (status === 'error' && error) {
      event.error = {
        name: error instanceof Error ? error.name : 'Error',
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      }
    }

    ipcRenderer.send('INSPECTOR:TRACE', event)
  } catch {}
}

// ============================================================================
// End Trace Helpers
// ============================================================================
`

/**
 * Creates the file header for generated React hooks files
 * @returns File header with auto-generation warning and lint/prettier ignores
 */
export const createReactHooksFileHeader = () => `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

import { useState, useCallback, useEffect, useRef } from 'react'
`

/**
 * Generates template for invoke contracts (Renderer ↔ Main bidirectional communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for invoke contract helper function
 */
export const invokeContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.invoke with the correct types enforced.
const invoke${contract} = <K extends keyof ${contract}>(
  channel: K,
  request: ${contract}[K]["request"],
  options?: TraceOptions
): Promise<${contract}[K]["response"]> => {
   return traceInvoke(
     channel as string,
     request,
     (ch, req) => ipcRenderer.invoke(ch, req) as Promise<${contract}[K]["response"]>,
     options?.trace
   )
}
`

/**
 * Generates template for event contracts (Renderer → Main one-way communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for event contract helper function
 */
export const eventContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.send with the correct types enforced.
const send${contract} = <K extends keyof ${contract}>(
  channel: K,
  request: ${contract}[K]["request"],
  options?: TraceOptions
): void => {
   const traceContext = traceEvent(channel as string, request, options?.trace)
   ipcRenderer.send(channel as string, wrapTracePayload(request, traceContext ?? undefined))
}
`

/**
 * Generates template for send/broadcast contracts (Main → Renderer one-way communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for broadcast contract helper function
 */
export const sendContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.on with the correct types enforced.
const on${contract} = <K extends keyof ${contract}>(
  channel: K,
  callback: (payload: ${contract}[K]["payload"]) => void,
  options?: TraceOptions
): (() => void) => {
   const handler = (_event: any, data: any) => {
     const { payload, trace } = unwrapTracePayload(data)
     traceBroadcast(channel as string, payload, trace ?? options?.trace)
     callback(payload)
   }
   ipcRenderer.on(channel as string, handler)
   return () => ipcRenderer.removeListener(channel as string, handler)
}
`

/**
 * Generates template for stream invoke contracts (Renderer ↔ Main with stream response)
 * Uses callback-based API for contextBridge compatibility (only serializable data)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream invoke contract helper function
 */
export const streamInvokeContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

/**
 * Callback handlers for stream invoke operations
 */
type StreamCallbacks<TData> = {
  onData: (chunk: TData) => void
  onEnd: () => void
  onError: (error: Error) => void
}

/**
 * Starts a stream invoke and handles the response via callbacks.
 * This approach works with contextBridge as it only transfers serializable data.
 */
const invokeStream${contract} = <K extends keyof ${contract}>(
  channel: K,
  request: ${contract}[K]["request"],
  callbacks: StreamCallbacks<${contract}[K]["stream"]>,
  options?: { signal?: AbortSignal } & TraceOptions
): (() => void) => {
   const traceContext = traceStreamInvoke(channel as string, request, options?.trace)
   const traceId = traceContext?.spanId ?? ''
   const tsStart = Date.now()

   const dataChannel = \`\${channel as string}-data\`
   const endChannel = \`\${channel as string}-end\`
   const errorChannel = \`\${channel as string}-error\`

   const dataHandler = (_event: any, chunk: ${contract}[K]["stream"]) => {
     const { payload } = unwrapTracePayload(chunk)
     traceStreamInvokeChunk(traceContext, channel as string, payload)
     callbacks.onData(payload)
   }
   const endHandler = (_event: any, _endPayload: any) => {
     traceStreamInvokeEnd(traceContext, channel as string, tsStart)
     callbacks.onEnd()
     cleanup()
   }
   const errorHandler = (_event: any, err: any) => {
     const { payload } = unwrapTracePayload(err)
     traceStreamInvokeError(traceContext, channel as string, tsStart, payload)
     callbacks.onError(payload instanceof Error ? payload : new Error(String(payload)))
     cleanup()
   }

   let isCleanedUp = false

   const cleanup = () => {
     if (isCleanedUp) return
     isCleanedUp = true
     ipcRenderer.removeListener(dataChannel, dataHandler)
     ipcRenderer.removeListener(endChannel, endHandler)
     ipcRenderer.removeListener(errorChannel, errorHandler)
     if (options?.signal) options.signal.removeEventListener('abort', handleAbort)
   }

   const stop = () => {
     traceStreamInvokeEnd(traceContext, channel as string, tsStart, 'cancelled')
     ipcRenderer.send(\`\${channel as string}-cancel\`)
     cleanup()
   }

   const handleAbort = () => {
     stop()
   }

   ipcRenderer.on(dataChannel, dataHandler)
   ipcRenderer.on(endChannel, endHandler)
   ipcRenderer.on(errorChannel, errorHandler)

   if (options?.signal) {
     if (options.signal.aborted) {
       stop()
       return stop
     }
     options.signal.addEventListener('abort', handleAbort, { once: true })
   }

   // Start the stream
   ipcRenderer.invoke(channel as string, wrapTracePayload(request, traceContext ?? undefined))

   return stop
}
`

/**
 * Generates template for stream upload contracts (Renderer → Main streaming)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream upload helper function
 */
export const streamUploadContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

type StreamWriter<T> = {
  write: (chunk: T) => Promise<void>
  close: () => Promise<void>
  abort: (reason?: any) => Promise<void>
}

// This function creates a stream writer for uploading data to the main process.
const upload${contract} = <K extends keyof ${contract}>(
  channel: K,
  request: ${contract}[K]["request"],
  options?: TraceOptions
): StreamWriter<${contract}[K]["data"]> => {
   const traceContext = traceStreamUploadStart(channel as string, request, options?.trace)
   const tsStart = Date.now()
   ipcRenderer.send(
     \`\${channel as string}-start\`,
     wrapTracePayload(request, traceContext ?? undefined)
   )
   return {
     write: async (chunk: ${contract}[K]["data"]) => {
       traceStreamUploadData(traceContext, channel as string, chunk)
       ipcRenderer.send(
         \`\${channel as string}-data\`,
         wrapTracePayload(chunk, traceContext ?? undefined)
       )
     },
     close: async () => {
       traceStreamUploadEnd(traceContext, channel as string, 'ok', undefined, tsStart)
       ipcRenderer.send(
         \`\${channel as string}-end\`,
         wrapTracePayload(undefined, traceContext ?? undefined)
       )
     },
     abort: async (reason?: any) => {
       const status = reason instanceof Error ? 'error' : 'cancelled'
       traceStreamUploadEnd(traceContext, channel as string, status, reason, tsStart)
       ipcRenderer.send(
         \`\${channel as string}-error\`,
         wrapTracePayload(reason, traceContext ?? undefined)
       )
     }
   }
}
`

/**
 * Generates template for stream download contracts (Main → Renderer streaming)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream download helper function
 */
export const streamDownloadContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function sets up listeners for downloading a stream from the main process.
const download${contract} = <K extends keyof ${contract}>(
  channel: K,
  request: ${contract}[K]["request"],
  callback: (data: ${contract}[K]["data"]) => void,
  onEnd?: () => void,
  onError?: (err: any) => void,
  options?: { signal?: AbortSignal } & TraceOptions
): (() => void) => {
   const dataChannel = \`\${channel as string}-data\`
   const endChannel = \`\${channel as string}-end\`
   const errorChannel = \`\${channel as string}-error\`
   const traceContext = shouldTraceChannel(channel as string)
     ? createTraceContext(options?.trace)
     : null
   const tsStart = Date.now()

   const dataHandler = (_event: any, data: ${contract}[K]["data"]) => {
     const { payload, trace } = unwrapTracePayload(data)
     traceStreamDownload(channel as string, payload, trace ?? traceContext ?? options?.trace)
     callback(payload)
   }
   const endHandler = () => {
     traceStreamDownloadEnd(traceContext, channel as string, tsStart)
     onEnd?.()
     cleanup()
   }
   const errorHandler = (_event: any, err: any) => {
     const { payload } = unwrapTracePayload(err)
     traceStreamDownloadEnd(traceContext, channel as string, tsStart, 'error', payload)
     onError?.(payload)
     cleanup()
   }

   let isCleanedUp = false

   const cleanup = () => {
     if (isCleanedUp) return
     isCleanedUp = true
     ipcRenderer.removeListener(dataChannel, dataHandler)
     ipcRenderer.removeListener(endChannel, endHandler)
     ipcRenderer.removeListener(errorChannel, errorHandler)
     if (options?.signal) options.signal.removeEventListener('abort', handleAbort)
   }

   const stop = () => {
     traceStreamDownloadEnd(traceContext, channel as string, tsStart, 'cancelled')
     ipcRenderer.send(\`\${channel as string}-cancel\`)
     cleanup()
   }

   const handleAbort = () => {
     stop()
   }

   if (options?.signal) {
     if (options.signal.aborted) {
       stop()
       return stop
     }
     options.signal.addEventListener('abort', handleAbort, { once: true })
   }

   ipcRenderer.on(dataChannel, dataHandler)
   ipcRenderer.on(endChannel, endHandler)
   ipcRenderer.on(errorChannel, errorHandler)
   ipcRenderer.invoke(
     channel as string,
     wrapTracePayload(request, traceContext ?? undefined)
   ) // Trigger the download with request
   return stop
}
`

/**
 * Generates an API method for a specific contract property
 * @param prefix - Method prefix (invoke, send, or on)
 * @param propName - Property/channel name
 * @param contract - Contract type name
 * @param paramType - Type of parameter (request or payload)
 * @param returnType - Return type hint (Promise wrapper or void)
 * @returns Method definition string
 */
export const createApiMethod = (
  prefix: string,
  propName: string,
  contract: string,
  paramType: 'request' | 'payload',
  returnType: 'promise' | 'void' | 'callback' | 'invoke' | 'stream' | 'upload' | 'download'
) => {
  const param = paramType === 'request' ? 'request' : 'content'
  const typeAnnotation = `${contract}["${propName}"]["${paramType}"]`

  if (returnType === 'void') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}, options?: TraceOptions) => {
   return ${prefix}${contract}("${propName}", ${param}, options)
},`
  }

  if (returnType === 'invoke') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}, options?: TraceOptions): Promise<${contract}["${propName}"]["response"]> => {
   return ${prefix}${contract}("${propName}", ${param}, options)
},`
  }

  if (returnType === 'stream') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}, callbacks: StreamCallbacks<${contract}["${propName}"]["stream"]>, options?: { signal?: AbortSignal } & TraceOptions): (() => void) => {
   return ${prefix}${contract}("${propName}", ${param}, callbacks, options)
},`
  }

  if (returnType === 'upload') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}, options?: TraceOptions): StreamWriter<${contract}["${propName}"]["data"]> => {
   return ${prefix}${contract}("${propName}", ${param}, options)
},`
  }

  if (returnType === 'download') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}, callback: (data: ${contract}["${propName}"]["data"]) => void, onEnd?: () => void, onError?: (err: any) => void, options?: { signal?: AbortSignal } & TraceOptions): (() => void) => {
   return ${prefix}${contract}("${propName}", ${param}, callback, onEnd, onError, options)
},`
  }

  const callbackType = `(${param}: ${typeAnnotation}) => void`
  return `${prefix}${propName}: (callback: ${callbackType}, options?: TraceOptions) => {
   return ${prefix}${contract}("${propName}", callback, options)
},`
} /**
 * Generates the final API export combining all contract APIs
 * @param apiNames - Array of API constant names to spread
 * @param apiName - Name of the exported API object (default: 'api')
 * @returns Export statements for api object and ApiType
 */
export const createApiExport = (apiNames: string[], apiName: string = 'api') => `
export const ${apiName} = {
${apiNames.map((name) => `   ...${name},`).join('\n')}
}
export type ${apiName.charAt(0).toUpperCase() + apiName.slice(1)}Type = typeof ${apiName}
`

/**
 * Generates the exposeApi function for preload scripts
 * @param apiName - Name of the API to expose (default: 'api')
 * @returns Function to expose the API via contextBridge
 */
export const createExposeApi = (apiName: string = 'api') => {
  const exposeFunctionName = `expose${apiName.charAt(0).toUpperCase() + apiName.slice(1)}`
  return `
/**
 * Exposes the generated IPC API to the renderer process via contextBridge
 * Handles context isolation automatically
 *
 * Usage in preload script:
 * \`\`\`typescript
 * import { ${exposeFunctionName}, ${apiName.charAt(0).toUpperCase() + apiName.slice(1)}Type } from './api-generated'
 *
 * declare global {
 *   interface Window {
 *     ${apiName}: ${apiName.charAt(0).toUpperCase() + apiName.slice(1)}Type
 *   }
 * }
 *
 * ${exposeFunctionName}()
 * \`\`\`
 */
export const ${exposeFunctionName} = () => {
  // Use \`contextBridge\` APIs to expose Electron APIs to
  // renderer only if context isolation is enabled, otherwise
  // just add to the DOM global.
  if (process.contextIsolated) {
    try {
      contextBridge.exposeInMainWorld('${apiName}', ${apiName})
    } catch (error) {
      console.error(error)
    }
  } else {
    ;(globalThis as any).${apiName} = ${apiName}
  }
}
`
}

/**
 * Creates the file header for generated Main Process files
 * @returns File header with auto-generation warning and lint/prettier ignores
 */
export const createMainFileHeader = () => `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

`

/**
 * Generates React hook for invoke contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React invoke hook
 */
export const reactInvokeHook = (contract: string, importPath: string, apiName: string = 'api') => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for invoke operations with automatic state management
 * @param channel - The IPC channel name
 * @returns Object with data, loading, error states and invoke function
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const [data, setData] = useState<${contract}[K]["response"] | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)

  const invoke = useCallback(async (request: ${contract}[K]["request"]) => {
    setLoading(true)
    setError(null)
    try {
      const methodName = \`invoke\${channel}\` as keyof typeof window.${apiName}
      const result = await (window.${apiName}[methodName] as any)(request)
      setData(result)
      return result
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error)
      throw error
    } finally {
      setLoading(false)
    }
  }, [channel])

  return { data, loading, error, invoke }
}
`
}

/**
 * Generates React hook for event contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React event hook
 */
export const reactEventHook = (contract: string, importPath: string, apiName: string = 'api') => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for event operations
 * @param channel - The IPC channel name
 * @returns Object with send function
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const send = useCallback((request: ${contract}[K]["request"]) => {
    const methodName = \`send\${channel}\` as keyof typeof window.${apiName}
    ;(window.${apiName}[methodName] as any)(request)
  }, [channel])

  return { send }
}
`
}

/**
 * Generates React hook for broadcast contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React broadcast hook
 */
export const reactBroadcastHook = (
  contract: string,
  importPath: string,
  apiName: string = 'api'
) => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for broadcast operations with automatic subscription management
 * @param channel - The IPC channel name
 * @returns Object with data, subscribe, and unsubscribe functions
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const [data, setData] = useState<${contract}[K]["payload"] | null>(null)

  const subscribe = useCallback((callback?: (payload: ${contract}[K]["payload"]) => void) => {
    const handler = (data: any) => {
      setData(data)
      callback?.(data)
    }
    const onMethodName = \`on\${channel}\` as keyof typeof window.${apiName}
    return (window.${apiName}[onMethodName] as any)(handler)
  }, [channel])

  return { data, subscribe }
}
`
}

/**
 * Generates React hook for stream invoke contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React stream invoke hook
 */
export const reactStreamInvokeHook = (
  contract: string,
  importPath: string,
  apiName: string = 'api'
) => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for stream invoke operations with automatic state management
 * @param channel - The IPC channel name
 * @returns Object with data, loading, error states and invoke function
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const [data, setData] = useState<${contract}[K]["stream"][]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const [isComplete, setIsComplete] = useState(false)
  const cleanupRef = useRef<(() => void) | null>(null)

  const invoke = useCallback((request: ${contract}[K]["request"]) => {
    cleanupRef.current?.()
    cleanupRef.current = null
    setLoading(true)
    setError(null)
    setData([])
    setIsComplete(false)

    const methodName = \`invokeStream\${channel}\` as keyof typeof window.${apiName}
    const cleanup = (window.${apiName}[methodName] as any)(request, {
      onData: (chunk: ${contract}[K]["stream"]) => {
        setData(prev => [...prev, chunk])
      },
      onEnd: () => {
        setLoading(false)
        setIsComplete(true)
        cleanupRef.current = null
      },
      onError: (err: Error) => {
        setError(err)
        setLoading(false)
        cleanupRef.current = null
      }
    })
    cleanupRef.current = cleanup
  }, [channel])

  const cancel = useCallback(() => {
    cleanupRef.current?.()
    cleanupRef.current = null
    setLoading(false)
    setIsComplete(false)
  }, [])

  const reset = useCallback(() => {
    cleanupRef.current?.()
    cleanupRef.current = null
    setData([])
    setError(null)
    setIsComplete(false)
  }, [])

  useEffect(() => {
    return () => {
      cleanupRef.current?.()
      cleanupRef.current = null
    }
  }, [])

  return { data, loading, error, isComplete, invoke, cancel, reset }
}
`
}

/**
 * Generates React hook for stream upload contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React stream upload hook
 */
export const reactStreamUploadHook = (
  contract: string,
  importPath: string,
  apiName: string = 'api'
) => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for stream upload operations
 * @param channel - The IPC channel name
 * @returns Object with writer and status
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const [isActive, setIsActive] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const writerRef = useRef<any>(null)

  const start = useCallback((request: ${contract}[K]["request"]) => {
    setIsActive(true)
    setError(null)
    const methodName = \`upload\${channel}\` as keyof typeof window.${apiName}
    writerRef.current = (window.${apiName}[methodName] as any)(request)
    return writerRef.current
  }, [channel])

  const write = useCallback(async (chunk: ${contract}[K]["data"]) => {
    if (!writerRef.current) throw new Error('Stream not started')
    try {
      await writerRef.current.write(chunk)
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error)
      throw error
    }
  }, [])

  const close = useCallback(async () => {
    if (!writerRef.current) return
    try {
      await writerRef.current.close()
      setIsActive(false)
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error)
      throw error
    }
  }, [])

  const abort = useCallback(async (reason?: any) => {
    if (!writerRef.current) return
    try {
      await writerRef.current.abort(reason)
      setIsActive(false)
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error)
      throw error
    }
  }, [])

  return { isActive, error, start, write, close, abort }
}
`
}

/**
 * Generates React hook for stream download contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React stream download hook
 */
export const reactStreamDownloadHook = (
  contract: string,
  importPath: string,
  apiName: string = 'api'
) => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for stream download operations with automatic state management
 * @param channel - The IPC channel name
 * @returns Object with data, loading, error states and download function
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const [data, setData] = useState<${contract}[K]["data"][]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const [isComplete, setIsComplete] = useState(false)
  const cleanupRef = useRef<(() => void) | null>(null)

  const download = useCallback((request: ${contract}[K]["request"]) => {
    cleanupRef.current?.()
    cleanupRef.current = null
    setLoading(true)
    setError(null)
    setData([])
    setIsComplete(false)

    const methodName = \`download\${channel}\` as keyof typeof window.${apiName}
    const cleanup = (window.${apiName}[methodName] as any)(request,
      (chunk: ${contract}[K]["data"]) => {
        setData(prev => [...prev, chunk])
      },
      () => {
        setLoading(false)
        setIsComplete(true)
        cleanupRef.current = null
      },
      (err: any) => {
        const error = err instanceof Error ? err : new Error(String(err))
        setError(error)
        setLoading(false)
        cleanupRef.current = null
      }
    )
    cleanupRef.current = cleanup
  }, [channel])

  const cancel = useCallback(() => {
    cleanupRef.current?.()
    cleanupRef.current = null
    setLoading(false)
    setIsComplete(false)
  }, [])

  const reset = useCallback(() => {
    cleanupRef.current?.()
    cleanupRef.current = null
    setData([])
    setError(null)
    setIsComplete(false)
  }, [])

  useEffect(() => {
    return () => {
      cleanupRef.current?.()
      cleanupRef.current = null
    }
  }, [])

  return { data, loading, error, isComplete, download, cancel, reset }
}
`
}

/**
 * Generates re-exports for all contract types used in this API
 * @param contractNames - Array of contract type names to re-export
 * @param importPath - Relative import path to the contract definitions
 * @returns Re-export statements for all contract types
 */
export const createContractReExports = (contractNames: string[], importPath: string) => {
  if (contractNames.length === 0) return ''

  return `
// Re-export contract types for convenience
export type {
${contractNames.map((name) => `  ${name},`).join('\n')}
} from "${importPath}"
`
}
