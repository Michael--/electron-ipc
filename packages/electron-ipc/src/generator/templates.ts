/**
 * Creates the file header for generated IPC API files
 * @returns File header with auto-generation warning and lint/prettier ignores
 */
export const createFileHeader = () => `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

import { ipcRenderer } from "electron"
`

/**
 * Generates template for invoke contracts (Renderer ↔ Main bidirectional communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for invoke contract helper function
 */
export const invokeContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.invoke with the correct types enforced.
const invoke${contract} = <K extends keyof ${contract}>(channel: K, request: ${contract}[K]["request"]): Promise<${contract}[K]["response"]> => {
   return ipcRenderer.invoke(channel as string, request) as Promise<${contract}[K]["response"]>
}
`

/**
 * Generates template for event contracts (Renderer → Main one-way communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for event contract helper function
 */
export const eventContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.send with the correct types enforced.
const send${contract} = <K extends keyof ${contract}>(channel: K, request: ${contract}[K]["request"]): void => {
   ipcRenderer.send(channel as string, request)
}
`

/**
 * Generates template for send/broadcast contracts (Main → Renderer one-way communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for broadcast contract helper function
 */
export const sendContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.on with the correct types enforced.
const on${contract} = <K extends keyof ${contract}>(channel: K, callback: (payload: ${contract}[K]["payload"]) => void): void => {
   ipcRenderer.on(channel as string, (_event, payload: ${contract}[K]["payload"]) => callback(payload))
}
`

/**
 * Generates template for stream invoke contracts (Renderer ↔ Main with stream response)
 * Uses callback-based API for contextBridge compatibility (only serializable data)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream invoke contract helper function
 */
export const streamInvokeContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

/**
 * Callback handlers for stream invoke operations
 */
type StreamCallbacks<TData> = {
  onData: (chunk: TData) => void
  onEnd: () => void
  onError: (error: Error) => void
}

/**
 * Starts a stream invoke and handles the response via callbacks.
 * This approach works with contextBridge as it only transfers serializable data.
 */
const invokeStream${contract} = <K extends keyof ${contract}>(
  channel: K,
  request: ${contract}[K]["request"],
  callbacks: StreamCallbacks<${contract}[K]["stream"]>
): void => {
   const dataChannel = \`\${channel as string}-data\`
   const endChannel = \`\${channel as string}-end\`
   const errorChannel = \`\${channel as string}-error\`

   const dataHandler = (_event: any, chunk: ${contract}[K]["stream"]) => {
     callbacks.onData(chunk)
   }
   const endHandler = () => {
     callbacks.onEnd()
     cleanup()
   }
   const errorHandler = (_event: any, err: any) => {
     callbacks.onError(err instanceof Error ? err : new Error(String(err)))
     cleanup()
   }

   const cleanup = () => {
     ipcRenderer.removeListener(dataChannel, dataHandler)
     ipcRenderer.removeListener(endChannel, endHandler)
     ipcRenderer.removeListener(errorChannel, errorHandler)
   }

   ipcRenderer.on(dataChannel, dataHandler)
   ipcRenderer.on(endChannel, endHandler)
   ipcRenderer.on(errorChannel, errorHandler)

   // Start the stream
   ipcRenderer.invoke(channel as string, request)
}
`

/**
 * Generates template for stream upload contracts (Renderer → Main streaming)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream upload helper function
 */
export const streamUploadContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

type StreamWriter<T> = {
  write: (chunk: T) => Promise<void>
  close: () => Promise<void>
  abort: (reason?: any) => Promise<void>
}

// This function creates a stream writer for uploading data to the main process.
const upload${contract} = <K extends keyof ${contract}>(channel: K): StreamWriter<${contract}[K]["data"]> => {
   ipcRenderer.send(\`\${channel}-start\`)
   return {
     write: async (chunk: ${contract}[K]["data"]) => {
       ipcRenderer.send(\`\${channel}-data\`, chunk)
     },
     close: async () => {
       ipcRenderer.send(\`\${channel}-end\`)
     },
     abort: async (reason?: any) => {
       ipcRenderer.send(\`\${channel}-error\`, reason)
     }
   }
}
`

/**
 * Generates template for stream download contracts (Main → Renderer streaming)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream download helper function
 */
export const streamDownloadContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function sets up listeners for downloading a stream from the main process.
const download${contract} = <K extends keyof ${contract}>(channel: K, callback: (data: ${contract}[K]["data"]) => void, onEnd?: () => void, onError?: (err: any) => void): void => {
   ipcRenderer.on(\`\${channel}-data\`, (_event, data: ${contract}[K]["data"]) => callback(data))
   if (onEnd) ipcRenderer.on(\`\${channel}-end\`, onEnd)
   if (onError) ipcRenderer.on(\`\${channel}-error\`, (_event, err) => onError(err))
   ipcRenderer.invoke(channel as string) // Trigger the download
}
`

/**
 * Generates an API method for a specific contract property
 * @param prefix - Method prefix (invoke, send, or on)
 * @param propName - Property/channel name
 * @param contract - Contract type name
 * @param paramType - Type of parameter (request or payload)
 * @param returnType - Return type hint (Promise wrapper or void)
 * @returns Method definition string
 */
export const createApiMethod = (
  prefix: string,
  propName: string,
  contract: string,
  paramType: 'request' | 'payload',
  returnType: 'promise' | 'void' | 'callback' | 'invoke' | 'stream' | 'upload' | 'download'
) => {
  const param = paramType === 'request' ? 'request' : 'content'
  const typeAnnotation = `${contract}["${propName}"]["${paramType}"]`

  if (returnType === 'void') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}) => {
   return ${prefix}${contract}("${propName}", ${param})
},`
  }

  if (returnType === 'invoke') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}): Promise<${contract}["${propName}"]["response"]> => {
   return ${prefix}${contract}("${propName}", ${param})
},`
  }

  if (returnType === 'stream') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}, callbacks: StreamCallbacks<${contract}["${propName}"]["stream"]>): void => {
   return ${prefix}${contract}("${propName}", ${param}, callbacks)
},`
  }

  if (returnType === 'upload') {
    return `${prefix}${propName}: (): StreamWriter<${contract}["${propName}"]["data"]> => {
   return ${prefix}${contract}("${propName}")
},`
  }

  if (returnType === 'download') {
    return `${prefix}${propName}: (callback: (${param}: ${typeAnnotation}) => void, onEnd?: () => void, onError?: (err: any) => void): void => {
   return ${prefix}${contract}("${propName}", callback, onEnd, onError)
},`
  }

  const callbackType = `(${param}: ${typeAnnotation}) => void`
  return `${prefix}${propName}: (callback: ${callbackType}) => {
   return ${prefix}${contract}("${propName}", callback)
},`
}

/**
 * Generates the final API export combining all contract APIs
 * @param apiNames - Array of API constant names to spread
 * @returns Export statements for api object and ApiType
 */
export const createApiExport = (apiNames: string[]) => `
export const api = {
${apiNames.map((name) => `   ...${name},`).join('\n')}
}
export type ApiType = typeof api
`

/**
 * Generates the exposeApi function for preload scripts
 * @returns Function to expose the API via contextBridge
 */
export const createExposeApi = () => `
/**
 * Exposes the generated IPC API to the renderer process via contextBridge
 * Handles context isolation automatically
 *
 * Usage in preload script:
 * \`\`\`typescript
 * import { exposeApi, ApiType } from './api-generated'
 *
 * declare global {
 *   interface Window {
 *     api: ApiType
 *   }
 * }
 *
 * exposeApi()
 * \`\`\`
 */
export const exposeApi = () => {
  // Use \`contextBridge\` APIs to expose Electron APIs to
  // renderer only if context isolation is enabled, otherwise
  // just add to the DOM global.
  if (process.contextIsolated) {
    try {
      require('electron').contextBridge.exposeInMainWorld('api', api)
    } catch (error) {
      console.error(error)
    }
  } else {
    ;(globalThis as any).api = api
  }
}
`

/**
 * Creates the file header for generated Main Process files
 * @returns File header with auto-generation warning and lint/prettier ignores
 */
export const createMainFileHeader = () => `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

`
