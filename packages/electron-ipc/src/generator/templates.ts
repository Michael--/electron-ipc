/**
 * Creates the file header for generated IPC API files
 * @returns File header with auto-generation warning and lint/prettier ignores
 */
export const createFileHeader = () => `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

import { ipcRenderer } from "electron"
`

/**
 * Generates template for invoke contracts (Renderer ↔ Main bidirectional communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for invoke contract helper function
 */
export const invokeContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.invoke with the correct types enforced.
const invoke${contract} = <K extends keyof ${contract}>(channel: K, request: ${contract}[K]["request"]): Promise<${contract}[K]["response"]> => {
   return ipcRenderer.invoke(channel as string, request) as Promise<${contract}[K]["response"]>
}
`

/**
 * Generates template for event contracts (Renderer → Main one-way communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for event contract helper function
 */
export const eventContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.send with the correct types enforced.
const send${contract} = <K extends keyof ${contract}>(channel: K, request: ${contract}[K]["request"]): void => {
   ipcRenderer.send(channel as string, request)
}
`

/**
 * Generates template for send/broadcast contracts (Main → Renderer one-way communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for broadcast contract helper function
 */
export const sendContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.on with the correct types enforced.
const on${contract} = <K extends keyof ${contract}>(channel: K, callback: (payload: ${contract}[K]["payload"]) => void): void => {
   ipcRenderer.on(channel as string, (_event, payload: ${contract}[K]["payload"]) => callback(payload))
}
`

/**
 * Generates template for stream invoke contracts (Renderer ↔ Main with stream response)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream invoke contract helper function
 */
export const streamInvokeContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function starts a stream invoke and returns a ReadableStream for the response.
const invokeStream${contract} = <K extends keyof ${contract}>(channel: K, request: ${contract}[K]["request"]): ReadableStream<${contract}[K]["stream"]> => {
   ipcRenderer.invoke(channel as string, request)
   return new ReadableStream({
     start(controller) {
       ipcRenderer.on(\`\${channel}-data\`, (_event, chunk: ${contract}[K]["stream"]) => {
         controller.enqueue(chunk)
       })
       ipcRenderer.on(\`\${channel}-end\`, () => {
         controller.close()
       })
       ipcRenderer.on(\`\${channel}-error\`, (_event, err) => {
         controller.error(err)
       })
     }
   })
}
`

/**
 * Generates template for stream upload contracts (Renderer → Main streaming)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream upload helper function
 */
export const streamUploadContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function creates a writable stream for uploading data to the main process.
const upload${contract} = <K extends keyof ${contract}>(channel: K): WritableStream<${contract}[K]["data"]> => {
   ipcRenderer.send(\`\${channel}-start\`)
   return new WritableStream({
     write(chunk: ${contract}[K]["data"]) {
       ipcRenderer.send(\`\${channel}-data\`, chunk)
     },
     close() {
       ipcRenderer.send(\`\${channel}-end\`)
     },
     abort(err) {
       ipcRenderer.send(\`\${channel}-error\`, err)
     }
   })
}
`

/**
 * Generates template for stream download contracts (Main → Renderer streaming)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream download helper function
 */
export const streamDownloadContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function sets up listeners for downloading a stream from the main process.
const download${contract} = <K extends keyof ${contract}>(channel: K, callback: (data: ${contract}[K]["data"]) => void, onEnd?: () => void, onError?: (err: any) => void): void => {
   ipcRenderer.on(\`\${channel}-data\`, (_event, data: ${contract}[K]["data"]) => callback(data))
   if (onEnd) ipcRenderer.on(\`\${channel}-end\`, onEnd)
   if (onError) ipcRenderer.on(\`\${channel}-error\`, (_event, err) => onError(err))
   ipcRenderer.invoke(channel as string) // Trigger the download
}
`

/**
 * Generates an API method for a specific contract property
 * @param prefix - Method prefix (invoke, send, or on)
 * @param propName - Property/channel name
 * @param contract - Contract type name
 * @param paramType - Type of parameter (request or payload)
 * @param returnType - Return type hint (Promise wrapper or void)
 * @returns Method definition string
 */
export const createApiMethod = (
  prefix: string,
  propName: string,
  contract: string,
  paramType: 'request' | 'payload',
  returnType: 'promise' | 'void' | 'callback' | 'invoke' | 'stream' | 'upload' | 'download'
) => {
  const param = paramType === 'request' ? 'request' : 'content'
  const typeAnnotation = `${contract}["${propName}"]["${paramType}"]`

  if (returnType === 'void') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}) => {
   return ${prefix}${contract}("${propName}", ${param})
},`
  }

  if (returnType === 'invoke') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}): Promise<${contract}["${propName}"]["response"]> => {
   return ${prefix}${contract}("${propName}", ${param})
},`
  }

  if (returnType === 'stream') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}): ReadableStream<${contract}["${propName}"]["stream"]> => {
   return ${prefix}${contract}("${propName}", ${param})
},`
  }

  if (returnType === 'upload') {
    return `${prefix}${propName}: (): WritableStream<${contract}["${propName}"]["data"]> => {
   return ${prefix}${contract}("${propName}")
},`
  }

  if (returnType === 'download') {
    return `${prefix}${propName}: (callback: (${param}: ${typeAnnotation}) => void, onEnd?: () => void, onError?: (err: any) => void): void => {
   return ${prefix}${contract}("${propName}", callback, onEnd, onError)
},`
  }

  const callbackType = `(${param}: ${typeAnnotation}) => void`
  return `${prefix}${propName}: (callback: ${callbackType}) => {
   return ${prefix}${contract}("${propName}", callback)
},`
}

/**
 * Generates the final API export combining all contract APIs
 * @param apiNames - Array of API constant names to spread
 * @returns Export statements for api object and ApiType
 */
export const createApiExport = (apiNames: string[]) => `
export const api = {
${apiNames.map((name) => `   ...${name},`).join('\n')}
}
export type ApiType = typeof api
`

/**
 * Generates the exposeApi function for preload scripts
 * @returns Function to expose the API via contextBridge
 */
export const createExposeApi = () => `
/**
 * Exposes the generated IPC API to the renderer process via contextBridge
 * Handles context isolation automatically
 *
 * Usage in preload script:
 * \`\`\`typescript
 * import { exposeApi, ApiType } from './api-generated'
 *
 * declare global {
 *   interface Window {
 *     api: ApiType
 *   }
 * }
 *
 * exposeApi()
 * \`\`\`
 */
export const exposeApi = () => {
  // Use \`contextBridge\` APIs to expose Electron APIs to
  // renderer only if context isolation is enabled, otherwise
  // just add to the DOM global.
  if (process.contextIsolated) {
    try {
      require('electron').contextBridge.exposeInMainWorld('api', api)
    } catch (error) {
      console.error(error)
    }
  } else {
    ;(globalThis as any).api = api
  }
}
`

/**
 * Creates the file header for generated Main Process files
 * @returns File header with auto-generation warning and lint/prettier ignores
 */
export const createMainFileHeader = () => `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

`
