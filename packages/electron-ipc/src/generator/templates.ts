/**
 * Creates the file header for generated IPC API files
 * @returns File header with auto-generation warning and lint/prettier ignores
 */
export const createFileHeader = () => `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

import { ipcRenderer } from "electron"
`

/**
 * Creates the file header for generated React hooks files
 * @returns File header with auto-generation warning and lint/prettier ignores
 */
export const createReactHooksFileHeader = () => `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

import { useState, useCallback, useRef } from 'react'
`

/**
 * Generates template for invoke contracts (Renderer ↔ Main bidirectional communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for invoke contract helper function
 */
export const invokeContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.invoke with the correct types enforced.
const invoke${contract} = <K extends keyof ${contract}>(channel: K, request: ${contract}[K]["request"]): Promise<${contract}[K]["response"]> => {
   return ipcRenderer.invoke(channel as string, request) as Promise<${contract}[K]["response"]>
}
`

/**
 * Generates template for event contracts (Renderer → Main one-way communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for event contract helper function
 */
export const eventContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.send with the correct types enforced.
const send${contract} = <K extends keyof ${contract}>(channel: K, request: ${contract}[K]["request"]): void => {
   ipcRenderer.send(channel as string, request)
}
`

/**
 * Generates template for send/broadcast contracts (Main → Renderer one-way communication)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for broadcast contract helper function
 */
export const sendContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function takes the channel and request, infers the types, and calls ipcRenderer.on with the correct types enforced.
const on${contract} = <K extends keyof ${contract}>(channel: K, callback: (payload: ${contract}[K]["payload"]) => void): (() => void) => {
   const handler = (event: any, data: any) => callback(data)
   ipcRenderer.on(channel as string, handler)
   return () => ipcRenderer.removeListener(channel as string, handler)
}
`

/**
 * Generates template for stream invoke contracts (Renderer ↔ Main with stream response)
 * Uses callback-based API for contextBridge compatibility (only serializable data)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream invoke contract helper function
 */
export const streamInvokeContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

/**
 * Callback handlers for stream invoke operations
 */
type StreamCallbacks<TData> = {
  onData: (chunk: TData) => void
  onEnd: () => void
  onError: (error: Error) => void
}

/**
 * Starts a stream invoke and handles the response via callbacks.
 * This approach works with contextBridge as it only transfers serializable data.
 */
const invokeStream${contract} = <K extends keyof ${contract}>(
  channel: K,
  request: ${contract}[K]["request"],
  callbacks: StreamCallbacks<${contract}[K]["stream"]>
): void => {
   const dataChannel = \`\${channel as string}-data\`
   const endChannel = \`\${channel as string}-end\`
   const errorChannel = \`\${channel as string}-error\`

   const dataHandler = (_event: any, chunk: ${contract}[K]["stream"]) => {
     callbacks.onData(chunk)
   }
   const endHandler = () => {
     callbacks.onEnd()
     cleanup()
   }
   const errorHandler = (_event: any, err: any) => {
     callbacks.onError(err instanceof Error ? err : new Error(String(err)))
     cleanup()
   }

   const cleanup = () => {
     ipcRenderer.removeListener(dataChannel, dataHandler)
     ipcRenderer.removeListener(endChannel, endHandler)
     ipcRenderer.removeListener(errorChannel, errorHandler)
   }

   ipcRenderer.on(dataChannel, dataHandler)
   ipcRenderer.on(endChannel, endHandler)
   ipcRenderer.on(errorChannel, errorHandler)

   // Start the stream
   ipcRenderer.invoke(channel as string, request)
}
`

/**
 * Generates template for stream upload contracts (Renderer → Main streaming)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream upload helper function
 */
export const streamUploadContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

type StreamWriter<T> = {
  write: (chunk: T) => Promise<void>
  close: () => Promise<void>
  abort: (reason?: any) => Promise<void>
}

// This function creates a stream writer for uploading data to the main process.
const upload${contract} = <K extends keyof ${contract}>(
  channel: K,
  request: ${contract}[K]["request"]
): StreamWriter<${contract}[K]["data"]> => {
   ipcRenderer.send(\`\${channel as string}-start\`, request)
   return {
     write: async (chunk: ${contract}[K]["data"]) => {
       ipcRenderer.send(\`\${channel as string}-data\`, chunk)
     },
     close: async () => {
       ipcRenderer.send(\`\${channel as string}-end\`)
     },
     abort: async (reason?: any) => {
       ipcRenderer.send(\`\${channel as string}-error\`, reason)
     }
   }
}
`

/**
 * Generates template for stream download contracts (Main → Renderer streaming)
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for stream download helper function
 */
export const streamDownloadContracts = (contract: string, importPath: string) => `
import { ${contract} } from "${importPath}"

// This function sets up listeners for downloading a stream from the main process.
const download${contract} = <K extends keyof ${contract}>(
  channel: K,
  request: ${contract}[K]["request"],
  callback: (data: ${contract}[K]["data"]) => void,
  onEnd?: () => void,
  onError?: (err: any) => void
): void => {
   ipcRenderer.on(\`\${channel as string}-data\`, (_event, data: ${contract}[K]["data"]) => callback(data))
   if (onEnd) ipcRenderer.on(\`\${channel as string}-end\`, onEnd)
   if (onError) ipcRenderer.on(\`\${channel as string}-error\`, (_event, err) => onError(err))
   ipcRenderer.invoke(channel as string, request) // Trigger the download with request
}
`

/**
 * Generates an API method for a specific contract property
 * @param prefix - Method prefix (invoke, send, or on)
 * @param propName - Property/channel name
 * @param contract - Contract type name
 * @param paramType - Type of parameter (request or payload)
 * @param returnType - Return type hint (Promise wrapper or void)
 * @returns Method definition string
 */
export const createApiMethod = (
  prefix: string,
  propName: string,
  contract: string,
  paramType: 'request' | 'payload',
  returnType: 'promise' | 'void' | 'callback' | 'invoke' | 'stream' | 'upload' | 'download'
) => {
  const param = paramType === 'request' ? 'request' : 'content'
  const typeAnnotation = `${contract}["${propName}"]["${paramType}"]`

  if (returnType === 'void') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}) => {
   return ${prefix}${contract}("${propName}", ${param})
},`
  }

  if (returnType === 'invoke') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}): Promise<${contract}["${propName}"]["response"]> => {
   return ${prefix}${contract}("${propName}", ${param})
},`
  }

  if (returnType === 'stream') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}, callbacks: StreamCallbacks<${contract}["${propName}"]["stream"]>): void => {
   return ${prefix}${contract}("${propName}", ${param}, callbacks)
},`
  }

  if (returnType === 'upload') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}): StreamWriter<${contract}["${propName}"]["data"]> => {
   return ${prefix}${contract}("${propName}", ${param})
},`
  }

  if (returnType === 'download') {
    return `${prefix}${propName}: (${param}: ${typeAnnotation}, callback: (data: ${contract}["${propName}"]["data"]) => void, onEnd?: () => void, onError?: (err: any) => void): void => {
   return ${prefix}${contract}("${propName}", ${param}, callback, onEnd, onError)
},`
  }

  const callbackType = `(${param}: ${typeAnnotation}) => void`
  return `${prefix}${propName}: (callback: ${callbackType}) => {
   return ${prefix}${contract}("${propName}", callback)
},`
} /**
 * Generates the final API export combining all contract APIs
 * @param apiNames - Array of API constant names to spread
 * @param apiName - Name of the exported API object (default: 'api')
 * @returns Export statements for api object and ApiType
 */
export const createApiExport = (apiNames: string[], apiName: string = 'api') => `
export const ${apiName} = {
${apiNames.map((name) => `   ...${name},`).join('\n')}
}
export type ${apiName.charAt(0).toUpperCase() + apiName.slice(1)}Type = typeof ${apiName}
`

/**
 * Generates the exposeApi function for preload scripts
 * @param apiName - Name of the API to expose (default: 'api')
 * @returns Function to expose the API via contextBridge
 */
export const createExposeApi = (apiName: string = 'api') => {
  const exposeFunctionName = `expose${apiName.charAt(0).toUpperCase() + apiName.slice(1)}`
  return `
/**
 * Exposes the generated IPC API to the renderer process via contextBridge
 * Handles context isolation automatically
 *
 * Usage in preload script:
 * \`\`\`typescript
 * import { ${exposeFunctionName}, ${apiName.charAt(0).toUpperCase() + apiName.slice(1)}Type } from './api-generated'
 *
 * declare global {
 *   interface Window {
 *     ${apiName}: ${apiName.charAt(0).toUpperCase() + apiName.slice(1)}Type
 *   }
 * }
 *
 * ${exposeFunctionName}()
 * \`\`\`
 */
export const ${exposeFunctionName} = () => {
  // Use \`contextBridge\` APIs to expose Electron APIs to
  // renderer only if context isolation is enabled, otherwise
  // just add to the DOM global.
  if (process.contextIsolated) {
    try {
      require('electron').contextBridge.exposeInMainWorld('${apiName}', ${apiName})
    } catch (error) {
      console.error(error)
    }
  } else {
    ;(globalThis as any).${apiName} = ${apiName}
  }
}
`
}

/**
 * Creates the file header for generated Main Process files
 * @returns File header with auto-generation warning and lint/prettier ignores
 */
export const createMainFileHeader = () => `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

`

/**
 * Generates React hook for invoke contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React invoke hook
 */
export const reactInvokeHook = (contract: string, importPath: string, apiName: string = 'api') => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for invoke operations with automatic state management
 * @param channel - The IPC channel name
 * @returns Object with data, loading, error states and invoke function
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const [data, setData] = useState<${contract}[K]["response"] | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)

  const invoke = useCallback(async (request: ${contract}[K]["request"]) => {
    setLoading(true)
    setError(null)
    try {
      const methodName = \`invoke\${channel}\` as keyof typeof window.${apiName}
      const result = await (window.${apiName}[methodName] as any)(request)
      setData(result)
      return result
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error)
      throw error
    } finally {
      setLoading(false)
    }
  }, [channel])

  return { data, loading, error, invoke }
}
`
}

/**
 * Generates React hook for event contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React event hook
 */
export const reactEventHook = (contract: string, importPath: string, apiName: string = 'api') => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for event operations
 * @param channel - The IPC channel name
 * @returns Object with send function
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const send = useCallback((request: ${contract}[K]["request"]) => {
    const methodName = \`send\${channel}\` as keyof typeof window.${apiName}
    ;(window.${apiName}[methodName] as any)(request)
  }, [channel])

  return { send }
}
`
}

/**
 * Generates React hook for broadcast contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React broadcast hook
 */
export const reactBroadcastHook = (
  contract: string,
  importPath: string,
  apiName: string = 'api'
) => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for broadcast operations with automatic subscription management
 * @param channel - The IPC channel name
 * @returns Object with data, subscribe, and unsubscribe functions
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const [data, setData] = useState<${contract}[K]["payload"] | null>(null)

  const subscribe = useCallback((callback?: (payload: ${contract}[K]["payload"]) => void) => {
    const handler = (data: any) => {
      setData(data)
      callback?.(data)
    }
    const onMethodName = \`on\${channel}\` as keyof typeof window.${apiName}
    return (window.${apiName}[onMethodName] as any)(handler)
  }, [channel])

  return { data, subscribe }
}
`
}

/**
 * Generates React hook for stream invoke contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React stream invoke hook
 */
export const reactStreamInvokeHook = (
  contract: string,
  importPath: string,
  apiName: string = 'api'
) => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for stream invoke operations with automatic state management
 * @param channel - The IPC channel name
 * @returns Object with data, loading, error states and invoke function
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const [data, setData] = useState<${contract}[K]["stream"][]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const [isComplete, setIsComplete] = useState(false)

  const invoke = useCallback((request: ${contract}[K]["request"]) => {
    setLoading(true)
    setError(null)
    setData([])
    setIsComplete(false)

    const methodName = \`invokeStream\${channel}\` as keyof typeof window.${apiName}
    ;(window.${apiName}[methodName] as any)(request, {
      onData: (chunk: ${contract}[K]["stream"]) => {
        setData(prev => [...prev, chunk])
      },
      onEnd: () => {
        setLoading(false)
        setIsComplete(true)
      },
      onError: (err: Error) => {
        setError(err)
        setLoading(false)
      }
    })
  }, [channel])

  const reset = useCallback(() => {
    setData([])
    setError(null)
    setIsComplete(false)
  }, [])

  return { data, loading, error, isComplete, invoke, reset }
}
`
}

/**
 * Generates React hook for stream upload contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React stream upload hook
 */
export const reactStreamUploadHook = (
  contract: string,
  importPath: string,
  apiName: string = 'api'
) => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for stream upload operations
 * @param channel - The IPC channel name
 * @returns Object with writer and status
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const [isActive, setIsActive] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const writerRef = useRef<any>(null)

  const start = useCallback((request: ${contract}[K]["request"]) => {
    setIsActive(true)
    setError(null)
    const methodName = \`upload\${channel}\` as keyof typeof window.${apiName}
    writerRef.current = (window.${apiName}[methodName] as any)(request)
    return writerRef.current
  }, [channel])

  const write = useCallback(async (chunk: ${contract}[K]["data"]) => {
    if (!writerRef.current) throw new Error('Stream not started')
    try {
      await writerRef.current.write(chunk)
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error)
      throw error
    }
  }, [])

  const close = useCallback(async () => {
    if (!writerRef.current) return
    try {
      await writerRef.current.close()
      setIsActive(false)
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error)
      throw error
    }
  }, [])

  const abort = useCallback(async (reason?: any) => {
    if (!writerRef.current) return
    try {
      await writerRef.current.abort(reason)
      setIsActive(false)
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error)
      throw error
    }
  }, [])

  return { isActive, error, start, write, close, abort }
}
`
}

/**
 * Generates React hook for stream download contracts
 * @param contract - The contract type name
 * @param importPath - Relative import path to the contract definition
 * @returns Template string for React stream download hook
 */
export const reactStreamDownloadHook = (
  contract: string,
  importPath: string,
  apiName: string = 'api'
) => {
  return `
import { ${contract} } from "${importPath}"

/**
 * React hook for stream download operations with automatic state management
 * @param channel - The IPC channel name
 * @returns Object with data, loading, error states and download function
 */
export function use${contract}<K extends keyof ${contract}>(channel: K) {
  const [data, setData] = useState<${contract}[K]["data"][]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const [isComplete, setIsComplete] = useState(false)

  const download = useCallback((request: ${contract}[K]["request"]) => {
    setLoading(true)
    setError(null)
    setData([])
    setIsComplete(false)

    const methodName = \`download\${channel}\` as keyof typeof window.${apiName}
    ;(window.${apiName}[methodName] as any)(request,
      (chunk: ${contract}[K]["data"]) => {
        setData(prev => [...prev, chunk])
      },
      () => {
        setLoading(false)
        setIsComplete(true)
      },
      (err: any) => {
        const error = err instanceof Error ? err : new Error(String(err))
        setError(error)
        setLoading(false)
      }
    )
  }, [channel])

  const reset = useCallback(() => {
    setData([])
    setError(null)
    setIsComplete(false)
  }, [])

  return { data, loading, error, isComplete, download, reset }
}
`
}

/**
 * Generates re-exports for all contract types used in this API
 * @param contractNames - Array of contract type names to re-export
 * @param importPath - Relative import path to the contract definitions
 * @returns Re-export statements for all contract types
 */
export const createContractReExports = (contractNames: string[], importPath: string) => {
  if (contractNames.length === 0) return ''

  return `
// Re-export contract types for convenience
export type {
${contractNames.map((name) => `  ${name},`).join('\n')}
} from "${importPath}"
`
}
