/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

import { ipcRenderer } from "electron"


import { InvokeContracts } from "../main/ipc-api"

// This function takes the channel and request, infers the types, and calls ipcRenderer.invoke with the correct types enforced.
const invokeInvokeContracts = <K extends keyof InvokeContracts>(channel: K, request: InvokeContracts[K]["request"]): Promise<InvokeContracts[K]["response"]> => {
   return ipcRenderer.invoke(channel as string, request) as Promise<InvokeContracts[K]["response"]>
}


const InvokeContractsApi = {
   invokeAddNumbers: (request: InvokeContracts["AddNumbers"]["request"]): Promise<InvokeContracts["AddNumbers"]["response"]> => {
   return invokeInvokeContracts("AddNumbers", request)
},
   invokeGetAppInfo: (request: InvokeContracts["GetAppInfo"]["request"]): Promise<InvokeContracts["GetAppInfo"]["response"]> => {
   return invokeInvokeContracts("GetAppInfo", request)
},
}

import { EventContracts } from "../main/ipc-api"

// This function takes the channel and request, infers the types, and calls ipcRenderer.send with the correct types enforced.
const sendEventContracts = <K extends keyof EventContracts>(channel: K, request: EventContracts[K]["request"]): void => {
   ipcRenderer.send(channel as string, request)
}


const EventContractsApi = {
   sendQuit: (request: EventContracts["Quit"]["request"]) => {
   return sendEventContracts("Quit", request)
},
   sendLogMessage: (request: EventContracts["LogMessage"]["request"]) => {
   return sendEventContracts("LogMessage", request)
},
}

import { BroadcastContracts } from "../main/ipc-api"

// This function takes the channel and request, infers the types, and calls ipcRenderer.on with the correct types enforced.
const onBroadcastContracts = <K extends keyof BroadcastContracts>(channel: K, callback: (payload: BroadcastContracts[K]["payload"]) => void): void => {
   ipcRenderer.on(channel as string, (_event, payload: BroadcastContracts[K]["payload"]) => callback(payload))
}


const BroadcastContractsApi = {
   onPing: (callback: (content: BroadcastContracts["Ping"]["payload"]) => void) => {
   return onBroadcastContracts("Ping", callback)
},
   onAbout: (callback: (content: BroadcastContracts["About"]["payload"]) => void) => {
   return onBroadcastContracts("About", callback)
},
}

import { StreamInvokeContracts } from "../main/ipc-api"

// This function starts a stream invoke and returns a ReadableStream for the response.
const invokeStreamStreamInvokeContracts = <K extends keyof StreamInvokeContracts>(channel: K, request: StreamInvokeContracts[K]["request"]): ReadableStream<StreamInvokeContracts[K]["stream"]> => {
   ipcRenderer.invoke(channel as string, request)
   return new ReadableStream({
     start(controller) {
       ipcRenderer.on(`${channel}-data`, (_event, chunk: StreamInvokeContracts[K]["stream"]) => {
         controller.enqueue(chunk)
       })
       ipcRenderer.on(`${channel}-end`, () => {
         controller.close()
       })
       ipcRenderer.on(`${channel}-error`, (_event, err) => {
         controller.error(err)
       })
     }
   })
}


const StreamInvokeContractsApi = {
   invokeStreamGetLargeData: (request: StreamInvokeContracts["GetLargeData"]["request"]): ReadableStream<StreamInvokeContracts["GetLargeData"]["stream"]> => {
   return invokeStreamStreamInvokeContracts("GetLargeData", request)
},
}

import { StreamUploadContracts } from "../main/ipc-api"

// This function creates a writable stream for uploading data to the main process.
const uploadStreamUploadContracts = <K extends keyof StreamUploadContracts>(channel: K): WritableStream<StreamUploadContracts[K]["data"]> => {
   ipcRenderer.send(`${channel}-start`)
   return new WritableStream({
     write(chunk: StreamUploadContracts[K]["data"]) {
       ipcRenderer.send(`${channel}-data`, chunk)
     },
     close() {
       ipcRenderer.send(`${channel}-end`)
     },
     abort(err) {
       ipcRenderer.send(`${channel}-error`, err)
     }
   })
}


const StreamUploadContractsApi = {
   uploadUploadFile: (): WritableStream<StreamUploadContracts["UploadFile"]["data"]> => {
   return uploadStreamUploadContracts("UploadFile")
},
}

import { StreamDownloadContracts } from "../main/ipc-api"

// This function sets up listeners for downloading a stream from the main process.
const downloadStreamDownloadContracts = <K extends keyof StreamDownloadContracts>(channel: K, callback: (data: StreamDownloadContracts[K]["data"]) => void, onEnd?: () => void, onError?: (err: any) => void): void => {
   ipcRenderer.on(`${channel}-data`, (_event, data: StreamDownloadContracts[K]["data"]) => callback(data))
   if (onEnd) ipcRenderer.on(`${channel}-end`, onEnd)
   if (onError) ipcRenderer.on(`${channel}-error`, (_event, err) => onError(err))
   ipcRenderer.invoke(channel as string) // Trigger the download
}


const StreamDownloadContractsApi = {
   downloadDownloadLogs: (callback: (content: StreamDownloadContracts["DownloadLogs"]["payload"]) => void, onEnd?: () => void, onError?: (err: any) => void): void => {
   return downloadStreamDownloadContracts("DownloadLogs", callback, onEnd, onError)
},
}

export const api = {
   ...InvokeContractsApi,
   ...EventContractsApi,
   ...BroadcastContractsApi,
   ...StreamInvokeContractsApi,
   ...StreamUploadContractsApi,
   ...StreamDownloadContractsApi,
}
export type ApiType = typeof api


/**
 * Exposes the generated IPC API to the renderer process via contextBridge
 * Handles context isolation automatically
 *
 * Usage in preload script:
 * ```typescript
 * import { exposeApi, ApiType } from './api-generated'
 *
 * declare global {
 *   interface Window {
 *     api: ApiType
 *   }
 * }
 *
 * exposeApi()
 * ```
 */
export const exposeApi = () => {
  // Use `contextBridge` APIs to expose Electron APIs to
  // renderer only if context isolation is enabled, otherwise
  // just add to the DOM global.
  if (process.contextIsolated) {
    try {
      require('electron').contextBridge.exposeInMainWorld('api', api)
    } catch (error) {
      console.error(error)
    }
  } else {
    ;(globalThis as any).api = api
  }
}

