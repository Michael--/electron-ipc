/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

import { ipcRenderer } from "electron"


import { InvokeContracts } from "../main/ipc-api"

// This function takes the channel and request, infers the types, and calls ipcRenderer.invoke with the correct types enforced.
const invokeInvokeContracts = <K extends keyof InvokeContracts>(channel: K, request: InvokeContracts[K]["request"]): Promise<InvokeContracts[K]["response"]> => {
   return ipcRenderer.invoke(channel as string, request) as Promise<InvokeContracts[K]["response"]>
}


const InvokeContractsApi = {
   invokeAddNumbers: (request: InvokeContracts["AddNumbers"]["request"]): Promise<InvokeContracts["AddNumbers"]["response"]> => {
   return invokeInvokeContracts("AddNumbers", request)
},
   invokeGetAppInfo: (request: InvokeContracts["GetAppInfo"]["request"]): Promise<InvokeContracts["GetAppInfo"]["response"]> => {
   return invokeInvokeContracts("GetAppInfo", request)
},
}

import { EventContracts } from "../main/ipc-api"

// This function takes the channel and request, infers the types, and calls ipcRenderer.send with the correct types enforced.
const sendEventContracts = <K extends keyof EventContracts>(channel: K, request: EventContracts[K]["request"]): void => {
   ipcRenderer.send(channel as string, request)
}


const EventContractsApi = {
   sendQuit: (request: EventContracts["Quit"]["request"]) => {
   return sendEventContracts("Quit", request)
},
   sendLogMessage: (request: EventContracts["LogMessage"]["request"]) => {
   return sendEventContracts("LogMessage", request)
},
}

import { BroadcastContracts } from "../main/ipc-api"

// This function takes the channel and request, infers the types, and calls ipcRenderer.on with the correct types enforced.
const onBroadcastContracts = <K extends keyof BroadcastContracts>(channel: K, callback: (payload: BroadcastContracts[K]["payload"]) => void): void => {
   ipcRenderer.on(channel as string, (_event, payload: BroadcastContracts[K]["payload"]) => callback(payload))
}


const BroadcastContractsApi = {
   onPing: (callback: (content: BroadcastContracts["Ping"]["payload"]) => void) => {
   return onBroadcastContracts("Ping", callback)
},
   onAbout: (callback: (content: BroadcastContracts["About"]["payload"]) => void) => {
   return onBroadcastContracts("About", callback)
},
}

import { StreamInvokeContracts } from "../main/ipc-api"

/**
 * Callback handlers for stream invoke operations
 */
type StreamCallbacks<TData> = {
  onData: (chunk: TData) => void
  onEnd: () => void
  onError: (error: Error) => void
}

/**
 * Starts a stream invoke and handles the response via callbacks.
 * This approach works with contextBridge as it only transfers serializable data.
 */
const invokeStreamStreamInvokeContracts = <K extends keyof StreamInvokeContracts>(
  channel: K,
  request: StreamInvokeContracts[K]["request"],
  callbacks: StreamCallbacks<StreamInvokeContracts[K]["stream"]>
): void => {
   const dataChannel = `${channel as string}-data`
   const endChannel = `${channel as string}-end`
   const errorChannel = `${channel as string}-error`

   const dataHandler = (_event: any, chunk: StreamInvokeContracts[K]["stream"]) => {
     callbacks.onData(chunk)
   }
   const endHandler = () => {
     callbacks.onEnd()
     cleanup()
   }
   const errorHandler = (_event: any, err: any) => {
     callbacks.onError(err instanceof Error ? err : new Error(String(err)))
     cleanup()
   }

   const cleanup = () => {
     ipcRenderer.removeListener(dataChannel, dataHandler)
     ipcRenderer.removeListener(endChannel, endHandler)
     ipcRenderer.removeListener(errorChannel, errorHandler)
   }

   ipcRenderer.on(dataChannel, dataHandler)
   ipcRenderer.on(endChannel, endHandler)
   ipcRenderer.on(errorChannel, errorHandler)

   // Start the stream
   ipcRenderer.invoke(channel as string, request)
}


const StreamInvokeContractsApi = {
   invokeStreamGetLargeData: (request: StreamInvokeContracts["GetLargeData"]["request"], callbacks: StreamCallbacks<StreamInvokeContracts["GetLargeData"]["stream"]>): void => {
   return invokeStreamStreamInvokeContracts("GetLargeData", request, callbacks)
},
}

import { StreamUploadContracts } from "../main/ipc-api"

type StreamWriter<T> = {
  write: (chunk: T) => Promise<void>
  close: () => Promise<void>
  abort: (reason?: any) => Promise<void>
}

// This function creates a stream writer for uploading data to the main process.
const uploadStreamUploadContracts = <K extends keyof StreamUploadContracts>(
  channel: K,
  request: StreamUploadContracts[K]["request"]
): StreamWriter<StreamUploadContracts[K]["data"]> => {
   ipcRenderer.send(`${channel as string}-start`, request)
   return {
     write: async (chunk: StreamUploadContracts[K]["data"]) => {
       ipcRenderer.send(`${channel as string}-data`, chunk)
     },
     close: async () => {
       ipcRenderer.send(`${channel as string}-end`)
     },
     abort: async (reason?: any) => {
       ipcRenderer.send(`${channel as string}-error`, reason)
     }
   }
}


const StreamUploadContractsApi = {
   uploadUploadFile: (request: StreamUploadContracts["UploadFile"]["request"]): StreamWriter<StreamUploadContracts["UploadFile"]["data"]> => {
   return uploadStreamUploadContracts("UploadFile", request)
},
}

import { StreamDownloadContracts } from "../main/ipc-api"

// This function sets up listeners for downloading a stream from the main process.
const downloadStreamDownloadContracts = <K extends keyof StreamDownloadContracts>(
  channel: K,
  request: StreamDownloadContracts[K]["request"],
  callback: (data: StreamDownloadContracts[K]["data"]) => void,
  onEnd?: () => void,
  onError?: (err: any) => void
): void => {
   ipcRenderer.on(`${channel as string}-data`, (_event, data: StreamDownloadContracts[K]["data"]) => callback(data))
   if (onEnd) ipcRenderer.on(`${channel as string}-end`, onEnd)
   if (onError) ipcRenderer.on(`${channel as string}-error`, (_event, err) => onError(err))
   ipcRenderer.invoke(channel as string, request) // Trigger the download with request
}


const StreamDownloadContractsApi = {
   downloadDownloadLogs: (request: StreamDownloadContracts["DownloadLogs"]["request"], callback: (data: StreamDownloadContracts["DownloadLogs"]["data"]) => void, onEnd?: () => void, onError?: (err: any) => void): void => {
   return downloadStreamDownloadContracts("DownloadLogs", request, callback, onEnd, onError)
},
   downloadStreamVideo: (request: StreamDownloadContracts["StreamVideo"]["request"], callback: (data: StreamDownloadContracts["StreamVideo"]["data"]) => void, onEnd?: () => void, onError?: (err: any) => void): void => {
   return downloadStreamDownloadContracts("StreamVideo", request, callback, onEnd, onError)
},
}

export const api = {
   ...InvokeContractsApi,
   ...EventContractsApi,
   ...BroadcastContractsApi,
   ...StreamInvokeContractsApi,
   ...StreamUploadContractsApi,
   ...StreamDownloadContractsApi,
}
export type ApiType = typeof api


/**
 * Exposes the generated IPC API to the renderer process via contextBridge
 * Handles context isolation automatically
 *
 * Usage in preload script:
 * ```typescript
 * import { exposeApi, ApiType } from './api-generated'
 *
 * declare global {
 *   interface Window {
 *     api: ApiType
 *   }
 * }
 *
 * exposeApi('api')
 * ```
 */
export const exposeApi = (name: string = 'api') => {
  // Use `contextBridge` APIs to expose Electron APIs to
  // renderer only if context isolation is enabled, otherwise
  // just add to the DOM global.
  if (process.contextIsolated) {
    try {
      require('electron').contextBridge.exposeInMainWorld(name, api)
    } catch (error) {
      console.error(error)
    }
  } else {
    ;(globalThis as any)[name] = api
  }
}

