/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

import { useState, useCallback, useEffect } from 'react'


import { StreamInvokeContracts } from "../main/ipc-api"

/**
 * React hook for stream invoke operations with automatic state management
 * @param channel - The IPC channel name
 * @returns Object with data, loading, error states and invoke function
 */
export function useStreamInvokeContracts<K extends keyof StreamInvokeContracts>(channel: K) {
  const [data, setData] = useState<StreamInvokeContracts[K]["stream"][]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const [isComplete, setIsComplete] = useState(false)

  const invoke = useCallback((request: StreamInvokeContracts[K]["request"]) => {
    setLoading(true)
    setError(null)
    setData([])
    setIsComplete(false)

    const methodName = `invokeStream${channel}` as keyof typeof window.streamApi
    ;(window.streamApi[methodName] as any)(request, {
      onData: (chunk: StreamInvokeContracts[K]["stream"]) => {
        setData(prev => [...prev, chunk])
      },
      onEnd: () => {
        setLoading(false)
        setIsComplete(true)
      },
      onError: (err: Error) => {
        setError(err)
        setLoading(false)
      }
    })
  }, [channel])

  const reset = useCallback(() => {
    setData([])
    setError(null)
    setIsComplete(false)
  }, [])

  return { data, loading, error, isComplete, invoke, reset }
}


import { StreamUploadContracts } from "../main/ipc-api"

/**
 * React hook for stream upload operations
 * @param channel - The IPC channel name
 * @returns Object with writer and status
 */
export function useStreamUploadContracts<K extends keyof StreamUploadContracts>(channel: K) {
  const [isActive, setIsActive] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const writerRef = useRef<any>(null)

  const start = useCallback((request: StreamUploadContracts[K]["request"]) => {
    setIsActive(true)
    setError(null)
    const methodName = `upload${channel}` as keyof typeof window.streamApi
    writerRef.current = (window.streamApi[methodName] as any)(request)
    return writerRef.current
  }, [channel])

  const write = useCallback(async (chunk: StreamUploadContracts[K]["data"]) => {
    if (!writerRef.current) throw new Error('Stream not started')
    try {
      await writerRef.current.write(chunk)
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error)
      throw error
    }
  }, [])

  const close = useCallback(async () => {
    if (!writerRef.current) return
    try {
      await writerRef.current.close()
      setIsActive(false)
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error)
      throw error
    }
  }, [])

  const abort = useCallback(async (reason?: any) => {
    if (!writerRef.current) return
    try {
      await writerRef.current.abort(reason)
      setIsActive(false)
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error)
      throw error
    }
  }, [])

  return { isActive, error, start, write, close, abort }
}


import { StreamDownloadContracts } from "../main/ipc-api"

/**
 * React hook for stream download operations with automatic state management
 * @param channel - The IPC channel name
 * @returns Object with data, loading, error states and download function
 */
export function useStreamDownloadContracts<K extends keyof StreamDownloadContracts>(channel: K) {
  const [data, setData] = useState<StreamDownloadContracts[K]["data"][]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const [isComplete, setIsComplete] = useState(false)

  const download = useCallback((request: StreamDownloadContracts[K]["request"]) => {
    setLoading(true)
    setError(null)
    setData([])
    setIsComplete(false)

    const methodName = `download${channel}` as keyof typeof window.streamApi
    ;(window.streamApi[methodName] as any)(request,
      (chunk: StreamDownloadContracts[K]["data"]) => {
        setData(prev => [...prev, chunk])
      },
      () => {
        setLoading(false)
        setIsComplete(true)
      },
      (err: any) => {
        const error = err instanceof Error ? err : new Error(String(err))
        setError(error)
        setLoading(false)
      }
    )
  }, [channel])

  const reset = useCallback(() => {
    setData([])
    setError(null)
    setIsComplete(false)
  }, [])

  return { data, loading, error, isComplete, download, reset }
}
