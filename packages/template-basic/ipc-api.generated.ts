/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

import { contextBridge, ipcRenderer } from "electron"

import { InvokeContracts } from './ipc-api'

// This function takes the channel and request, infers the types, and calls ipcRenderer.invoke with the correct types enforced.
const invokeInvokeContracts = <K extends keyof InvokeContracts>(
  channel: K,
  request: InvokeContracts[K]['request']
): Promise<InvokeContracts[K]['response']> => {
  return ipcRenderer.invoke(channel as string, request) as Promise<InvokeContracts[K]['response']>
}

const InvokeContractsApi = {
  invokeAddNumbers: (
    request: InvokeContracts['AddNumbers']['request']
  ): Promise<InvokeContracts['AddNumbers']['response']> => {
    return invokeInvokeContracts('AddNumbers', request)
  },
}

import { EventContracts } from './ipc-api'

// This function takes the channel and request, infers the types, and calls ipcRenderer.send with the correct types enforced.
const sendEventContracts = <K extends keyof EventContracts>(
  channel: K,
  request: EventContracts[K]['request']
): void => {
  ipcRenderer.send(channel as string, request)
}

const EventContractsApi = {
  sendLogMessage: (request: EventContracts['LogMessage']['request']) => {
    return sendEventContracts('LogMessage', request)
  },
}

import { BroadcastContracts } from './ipc-api'

// This function takes the channel and request, infers the types, and calls ipcRenderer.on with the correct types enforced.
const onBroadcastContracts = <K extends keyof BroadcastContracts>(
  channel: K,
  callback: (payload: BroadcastContracts[K]['payload']) => void
): (() => void) => {
  const handler = (event: any, data: any) => callback(data)
  ipcRenderer.on(channel as string, handler)
  return () => ipcRenderer.removeListener(channel as string, handler)
}

const BroadcastContractsApi = {
  onPing: (callback: (content: BroadcastContracts['Ping']['payload']) => void) => {
    return onBroadcastContracts('Ping', callback)
  },
  on: onBroadcastContracts,
}

import { StreamDownloadContracts } from './ipc-api'

// This function sets up listeners for downloading a stream from the main process.
const downloadStreamDownloadContracts = <K extends keyof StreamDownloadContracts>(
  channel: K,
  request: StreamDownloadContracts[K]['request'],
  callback: (data: StreamDownloadContracts[K]['data']) => void,
  onEnd?: () => void,
  onError?: (err: any) => void,
  options?: { signal?: AbortSignal }
): (() => void) => {
  const dataChannel = `${channel as string}-data`
  const endChannel = `${channel as string}-end`
  const errorChannel = `${channel as string}-error`

  const dataHandler = (_event: any, data: StreamDownloadContracts[K]['data']) => callback(data)
  const endHandler = () => {
    onEnd?.()
    cleanup()
  }
  const errorHandler = (_event: any, err: any) => {
    onError?.(err)
    cleanup()
  }

  let isCleanedUp = false

  const cleanup = () => {
    if (isCleanedUp) return
    isCleanedUp = true
    ipcRenderer.removeListener(dataChannel, dataHandler)
    ipcRenderer.removeListener(endChannel, endHandler)
    ipcRenderer.removeListener(errorChannel, errorHandler)
    if (options?.signal) options.signal.removeEventListener('abort', handleAbort)
  }

  const stop = () => {
    ipcRenderer.send(`${channel as string}-cancel`)
    cleanup()
  }

  const handleAbort = () => {
    stop()
  }

  if (options?.signal) {
    if (options.signal.aborted) {
      stop()
      return stop
    }
    options.signal.addEventListener('abort', handleAbort, { once: true })
  }

  ipcRenderer.on(dataChannel, dataHandler)
  ipcRenderer.on(endChannel, endHandler)
  ipcRenderer.on(errorChannel, errorHandler)
  ipcRenderer.invoke(channel as string, request) // Trigger the download with request
  return stop
}

const StreamDownloadContractsApi = {
  downloadDownloadLogs: (
    request: StreamDownloadContracts['DownloadLogs']['request'],
    callback: (data: StreamDownloadContracts['DownloadLogs']['data']) => void,
    onEnd?: () => void,
    onError?: (err: any) => void,
    options?: { signal?: AbortSignal }
  ): (() => void) => {
    return downloadStreamDownloadContracts(
      'DownloadLogs',
      request,
      callback,
      onEnd,
      onError,
      options
    )
  },
}

export const api = {
  ...InvokeContractsApi,
  ...EventContractsApi,
  ...BroadcastContractsApi,
  ...StreamDownloadContractsApi,
}
export type ApiType = typeof api

/**
 * Exposes the generated IPC API to the renderer process via contextBridge
 * Handles context isolation automatically
 *
 * Usage in preload script:
 * ```typescript
 * import { exposeApi, ApiType } from './api-generated'
 *
 * declare global {
 *   interface Window {
 *     api: ApiType
 *   }
 * }
 *
 * exposeApi()
 * ```
 */
export const exposeApi = () => {
  // Use `contextBridge` APIs to expose Electron APIs to
  // renderer only if context isolation is enabled, otherwise
  // just add to the DOM global.
  if (process.contextIsolated) {
    try {
      contextBridge.exposeInMainWorld('api', api)
    } catch (error) {
      console.error(error)
    }
  } else {
    ;(globalThis as any).api = api
  }
}

// Re-export contract types for convenience
export type {
  InvokeContracts,
  EventContracts,
  BroadcastContracts,
  StreamDownloadContracts,
} from './ipc-api'
