/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by electron-ipc-generate.
 * Any manual changes will be overwritten on next generation.
 */

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck

import { contextBridge, ipcRenderer } from "electron"

// ============================================================================
// Inline Trace Helpers (for Inspector)
// ============================================================================

/** Checks if tracing should be enabled for this channel */
function shouldTraceChannel(channel: string): boolean {
  // Never trace Inspector IPC (prevent circular tracing)
  if (channel.startsWith('INSPECTOR:')) return false
  return true
}

/** Generates a unique trace ID */
function generateTraceId(): string {
  return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`
}

/** Calculates byte size of JSON-serializable data */
function calculateBytes(data: any): number {
  try {
    return new Blob([JSON.stringify(data)]).size
  } catch {
    return 0
  }
}

/** Gets current payload mode from main process */
let cachedPayloadMode: 'none' | 'redacted' | 'full' = 'redacted'
try {
  // Try to get initial mode from main process
  ipcRenderer
    .invoke('INSPECTOR:GET_PAYLOAD_MODE')
    .then((mode) => {
      if (mode) cachedPayloadMode = mode
    })
    .catch(() => {})
} catch {}

/** Creates a payload preview based on current mode */
function createPayloadPreview(data: any): {
  mode: 'none' | 'redacted' | 'full'
  bytes?: number
  summary?: string
  data?: any
} {
  const bytes = calculateBytes(data)

  // Mode: none - no payload data at all
  if (cachedPayloadMode === 'none') {
    return { mode: 'none', bytes }
  }

  // Mode: full - include complete data
  if (cachedPayloadMode === 'full') {
    return { mode: 'full', bytes, data }
  }

  // Mode: redacted (default) - preview only
  let summary = ''
  try {
    const json = JSON.stringify(data)
    // Preview: first 100 chars
    summary = json.length > 100 ? json.slice(0, 100) + '...' : json
  } catch {
    summary = '[Non-serializable data]'
  }

  return { mode: 'redacted', bytes, summary }
}

/** Updates cached payload mode from main process */
ipcRenderer.on(
  'INSPECTOR:PAYLOAD_MODE_CHANGED',
  (_event: any, mode: 'none' | 'redacted' | 'full') => {
    cachedPayloadMode = mode
  }
)

/** Traces an invoke IPC call */
async function traceInvoke<TRequest, TResponse>(
  channel: string,
  request: TRequest,
  invoke: (channel: string, request: TRequest) => Promise<TResponse>
): Promise<TResponse> {
  if (!shouldTraceChannel(channel)) {
    return invoke(channel, request)
  }

  const traceId = generateTraceId()
  const tsStart = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceId,
      kind: 'invoke',
      channel,
      direction: 'renderer→main',
      status: 'ok',
      tsStart,
      source: { webContentsId: -1 },
      request: createPayloadPreview(request),
    })
  } catch {}

  try {
    const response = await invoke(channel, request)
    const tsEnd = Date.now()

    try {
      ipcRenderer.send('INSPECTOR:TRACE', {
        id: traceId,
        kind: 'invoke',
        channel,
        direction: 'renderer→main',
        status: 'ok',
        tsStart,
        tsEnd,
        durationMs: tsEnd - tsStart,
        source: { webContentsId: -1 },
        request: createPayloadPreview(request),
        response: createPayloadPreview(response),
      })
    } catch {}

    return response
  } catch (error) {
    const tsEnd = Date.now()

    try {
      ipcRenderer.send('INSPECTOR:TRACE', {
        id: traceId,
        kind: 'invoke',
        channel,
        direction: 'renderer→main',
        status: 'error',
        tsStart,
        tsEnd,
        durationMs: tsEnd - tsStart,
        source: { webContentsId: -1 },
        request: createPayloadPreview(request),
        error: {
          name: error instanceof Error ? error.name : 'Error',
          message: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined,
        },
      })
    } catch {}

    throw error
  }
}

/** Traces an event IPC call */
function traceEvent<TPayload>(channel: string, payload: TPayload): void {
  if (!shouldTraceChannel(channel)) return

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: generateTraceId(),
      kind: 'event',
      channel,
      direction: 'renderer→main',
      status: 'ok',
      tsStart: Date.now(),
      source: { webContentsId: -1 },
      payload: createPayloadPreview(payload),
    })
  } catch {}
}

/** Traces a broadcast IPC event */
function traceBroadcast<TPayload>(channel: string, payload: TPayload): void {
  if (!shouldTraceChannel(channel)) return

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: generateTraceId(),
      kind: 'broadcast',
      channel,
      direction: 'main→renderer',
      status: 'ok',
      tsStart: Date.now(),
      target: { webContentsId: -1 },
      payload: createPayloadPreview(payload),
    })
  } catch {}
}

/** Traces a stream invoke IPC call */
function traceStreamInvoke(channel: string, request: any): string {
  if (!shouldTraceChannel(channel)) return ''

  const traceId = generateTraceId()
  const tsStart = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceId,
      kind: 'streamInvoke',
      channel,
      direction: 'renderer→main',
      status: 'streaming',
      tsStart,
      source: { webContentsId: -1 },
      request: createPayloadPreview(request),
    })
  } catch {}

  return traceId
}

/** Updates stream invoke trace with chunk data */
function traceStreamInvokeChunk(traceId: string, channel: string, chunk: any): void {
  if (!traceId || !shouldTraceChannel(channel)) return

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceId,
      kind: 'streamInvoke',
      channel,
      direction: 'renderer→main',
      status: 'streaming',
      tsStart: Date.now(),
      source: { webContentsId: -1 },
      stream: createPayloadPreview(chunk),
    })
  } catch {}
}

/** Completes stream invoke trace */
function traceStreamInvokeEnd(traceId: string, channel: string, tsStart: number): void {
  if (!traceId || !shouldTraceChannel(channel)) return

  const tsEnd = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceId,
      kind: 'streamInvoke',
      channel,
      direction: 'renderer→main',
      status: 'ok',
      tsStart,
      tsEnd,
      durationMs: tsEnd - tsStart,
      source: { webContentsId: -1 },
    })
  } catch {}
}

/** Marks stream invoke as errored */
function traceStreamInvokeError(
  traceId: string,
  channel: string,
  tsStart: number,
  error: any
): void {
  if (!traceId || !shouldTraceChannel(channel)) return

  const tsEnd = Date.now()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceId,
      kind: 'streamInvoke',
      channel,
      direction: 'renderer→main',
      status: 'error',
      tsStart,
      tsEnd,
      durationMs: tsEnd - tsStart,
      source: { webContentsId: -1 },
      error: {
        name: error instanceof Error ? error.name : 'Error',
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
      },
    })
  } catch {}
}

/** Traces a stream upload start */
function traceStreamUploadStart(channel: string, request: any): string {
  if (!shouldTraceChannel(channel)) return ''

  const traceId = generateTraceId()

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceId,
      kind: 'streamUpload',
      channel,
      direction: 'renderer→main',
      status: 'streaming',
      tsStart: Date.now(),
      source: { webContentsId: -1 },
      request: createPayloadPreview(request),
    })
  } catch {}

  return traceId
}

/** Traces a stream upload data chunk */
function traceStreamUploadData(traceId: string, channel: string, chunk: any): void {
  if (!traceId || !shouldTraceChannel(channel)) return

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceId,
      kind: 'streamUpload',
      channel,
      direction: 'renderer→main',
      status: 'streaming',
      tsStart: Date.now(),
      source: { webContentsId: -1 },
      data: createPayloadPreview(chunk),
    })
  } catch {}
}

/** Traces stream upload completion */
function traceStreamUploadEnd(traceId: string, channel: string): void {
  if (!traceId || !shouldTraceChannel(channel)) return

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: traceId,
      kind: 'streamUpload',
      channel,
      direction: 'renderer→main',
      status: 'ok',
      tsStart: Date.now(),
      source: { webContentsId: -1 },
    })
  } catch {}
}

/** Traces a stream download */
function traceStreamDownload(channel: string, chunk: any): void {
  if (!shouldTraceChannel(channel)) return

  try {
    ipcRenderer.send('INSPECTOR:TRACE', {
      id: generateTraceId(),
      kind: 'streamDownload',
      channel,
      direction: 'main→renderer',
      status: 'ok',
      tsStart: Date.now(),
      target: { webContentsId: -1 },
      data: createPayloadPreview(chunk),
    })
  } catch {}
}

// ============================================================================
// End Trace Helpers
// ============================================================================

import { InvokeContracts } from './ipc-api'

// This function takes the channel and request, infers the types, and calls ipcRenderer.invoke with the correct types enforced.
const invokeInvokeContracts = <K extends keyof InvokeContracts>(
  channel: K,
  request: InvokeContracts[K]['request']
): Promise<InvokeContracts[K]['response']> => {
  return traceInvoke(
    channel as string,
    request,
    (ch, req) => ipcRenderer.invoke(ch, req) as Promise<InvokeContracts[K]['response']>
  )
}

const InvokeContractsApi = {
  invoketestPing: (
    request: InvokeContracts['testPing']['request']
  ): Promise<InvokeContracts['testPing']['response']> => {
    return invokeInvokeContracts('testPing', request)
  },
  invoketestHeavy: (
    request: InvokeContracts['testHeavy']['request']
  ): Promise<InvokeContracts['testHeavy']['response']> => {
    return invokeInvokeContracts('testHeavy', request)
  },
  invoketestError: (
    request: InvokeContracts['testError']['request']
  ): Promise<InvokeContracts['testError']['response']> => {
    return invokeInvokeContracts('testError', request)
  },
  invokecontrolStart: (
    request: InvokeContracts['controlStart']['request']
  ): Promise<InvokeContracts['controlStart']['response']> => {
    return invokeInvokeContracts('controlStart', request)
  },
  invokecontrolStop: (
    request: InvokeContracts['controlStop']['request']
  ): Promise<InvokeContracts['controlStop']['response']> => {
    return invokeInvokeContracts('controlStop', request)
  },
  invokecontrolStatus: (
    request: InvokeContracts['controlStatus']['request']
  ): Promise<InvokeContracts['controlStatus']['response']> => {
    return invokeInvokeContracts('controlStatus', request)
  },
}

import { EventContracts } from './ipc-api'

// This function takes the channel and request, infers the types, and calls ipcRenderer.send with the correct types enforced.
const sendEventContracts = <K extends keyof EventContracts>(
  channel: K,
  request: EventContracts[K]['request']
): void => {
  traceEvent(channel as string, request)
  ipcRenderer.send(channel as string, request)
}

const EventContractsApi = {
  sendtestEvent: (request: EventContracts['testEvent']['request']) => {
    return sendEventContracts('testEvent', request)
  },
}

import { BroadcastContracts } from './ipc-api'

// This function takes the channel and request, infers the types, and calls ipcRenderer.on with the correct types enforced.
const onBroadcastContracts = <K extends keyof BroadcastContracts>(
  channel: K,
  callback: (payload: BroadcastContracts[K]['payload']) => void
): (() => void) => {
  const handler = (event: any, data: any) => {
    traceBroadcast(channel as string, data)
    callback(data)
  }
  ipcRenderer.on(channel as string, handler)
  return () => ipcRenderer.removeListener(channel as string, handler)
}

const BroadcastContractsApi = {
  ontestBroadcast: (
    callback: (content: BroadcastContracts['testBroadcast']['payload']) => void
  ) => {
    return onBroadcastContracts('testBroadcast', callback)
  },
  on: onBroadcastContracts,
}

export const api = {
  ...InvokeContractsApi,
  ...EventContractsApi,
  ...BroadcastContractsApi,
}
export type ApiType = typeof api

/**
 * Exposes the generated IPC API to the renderer process via contextBridge
 * Handles context isolation automatically
 *
 * Usage in preload script:
 * ```typescript
 * import { exposeApi, ApiType } from './api-generated'
 *
 * declare global {
 *   interface Window {
 *     api: ApiType
 *   }
 * }
 *
 * exposeApi()
 * ```
 */
export const exposeApi = () => {
  // Use `contextBridge` APIs to expose Electron APIs to
  // renderer only if context isolation is enabled, otherwise
  // just add to the DOM global.
  if (process.contextIsolated) {
    try {
      contextBridge.exposeInMainWorld('api', api)
    } catch (error) {
      console.error(error)
    }
  } else {
    ;(globalThis as any).api = api
  }
}

// Re-export contract types for convenience
export type { InvokeContracts, EventContracts, BroadcastContracts } from './ipc-api'
